01:Derby Downloaded From https://db.apache.org/derby/releases/release-10.13.1.1.cgi.

02:Derby Started Using G:\WsApril17\DbDerby101311\bin\startNetworkServer.bat Script.See ScreenShot DerbyStarted.png.I Use It With Default Values.

03:Ddl Will Be Generated Automatically.Please Refer javax.persistence.schema-generation.database.action,javax.persistence.schema-generation.scripts.action.Location Is As Follows:javax.persistence.schema-generation.scripts.create-target,javax.persistence.schema-generation.scripts.drop-target.I Find It Helpful For Learning.

04:Jsr338(ToDo:MustRead):Specification.Standardized By Java Community Process.Jpa Needs A Runtime Provider Which Will Implement Jpa Specification.3 Implementation Are Available.EclipseLink,Hibernate,Apache OpenJpa.No Vendor Locking Benefit.

05:Managed Set Of Entities Is Called Persistence Context.Persistence Unit Is The Name For This Configuration.EntityManager Does Not Have Any Update Method.EntityManager Tracked When An Update Made To An Entity(Possibly Via Proxy).EntityManager Only Have persit,find & remove,merge(Method That Maked Detached Entity To Managed Entity) Method.

06:Jpa Use Convention Over Cofiguration/Configuration Is An Exception.Provider Apply This Default Rule.String(Varchar(255)).Annotation Can Be Applied On Field&Getters.Xml Overrides & Takes Precedence Over Annotation Metadata.If Database Info Got Changed Over Different Region Xml Usage. 

07:Direction:Traverse One Object From Another.UniDirectional/BiDirectional(Two UniDirectional).Cardinality(How Many Association Between Object).In Dbms Its Done By Primary Key,Foreign Key.In Oop Its Done By JoinColumn & JoinTable.

08:Every Story Has 3 Side(Yours,Mine,The Truth).First Is The View From One Side Of The Relationship,Second Is The View From Other Side Of The Relationship,Third One Is The Global Perspective That Knows About Both Side.Sides Are Called Role.One Entity Can Play Different Role In Different RelationShip.(Employee Entity Can Have Different Role In Department,Project,Even With Another Employee Entity As A Manager.).

09:Directionality:If Each Entity Point Back To Other Entity In A Relation Its BiDirectional.If Only One Entity Has A Pointer Then Its UniDirectional.Think Every BiDirectional Relationships As A Pair Of UniDirectional Relationship.So Based On Directionality We Refer One As Source Entity,Another One As Target Entity.Ex. Employee(Source) Works On A Project(Target),Project(Source) Consist Of Employees(Target).
######Change Persistent Unit Name In edu.gandhi.prajit.april.step03.TestRelationships
10:Single Valued Association(OneToOne,ManyToOne):In Dbms Foreign Key Implements The Relationship.In Jpa Term That Is JoinColumn.Now One Of The Two Side Will Have JoinColumn/ForeignKey Is Called OwningSide/Owner Of The Relationship.Otherside Of The Relationship Called NonOwning/Inverse Side.Cardinal Annotation(OneToOne,OneToMany,ManyToOne,ManyToMany) Are Logical Annotation.But Physical Annotation Like JoinColumn/JoinTable Applies In The Owning Side.
For ManyToOne Relation Physical Annotation Mapping Will Be Always On Many Side.Employee->Department Is ManyToOne.In Db Employee Will Hold The Foreign Key For Department,No Otherway Around.As Employee Holds The Foreign Key,Employee Will Be Owning/Source Entity.JoinColumn Will Be The Foreign Key Column Name In Source Entity Table.JoinColumn Is Not Required But Only To Override Column Name.Default Rule As Follows:<Name Of The Relationship Attribute In Source Entity>_<Name Of The Primary Key Column In Target Entity>.In Our Case Let Say Employee Entity Have private Department department;(<Name Of The Relationship Attribute In Source Entity>) & Suppose Department Has private String id;As Primary Key Column<Name Of The Primary Key Column In Target Entity>.In This ManyToOne Case,Without @JoinColumn Annotation ColumnName Will Be Department_Id In Employee Source Table.We Have Treated This Relation As UniDirectional.If We Add @OneToMany(mappedBy = "departmentVersion01")private Collection<EmployeeVersion01> employeeVersion01s; In DepartmentVersion01(Shown In DepartmentVersion02,EmployeeVersion02).Then It Will Be BiDirectional.If We Omit mappedBy = "departmentVersion01" In @OneToMany(mappedBy = "departmentVersion01") Then This Will Be Two Separate UniDirectional Relation(Shown In DepartmentVersion03,EmployeeVersion03).
####We Can Treat JoinColumn/JoinTable As A Strategy,If We Need Separate Table Use JoinTable Else JoinColumn.###############################
11:For OneToOne Relation Target Entity Is Not Shared Between Multiple Source Entity As In ManyToOne Case.Employee(Source,Table Has ForeignKey) Has ParkingSpace.In UniDirectional Case We Provide Annotation In Source Entity As In ManyToOne Case.To Decide Source Entity In This UniDirectional Case Assume Primary Key Of ParkingSpace Table Present In Employee Table As Foreign Key. So Employee Entity Becomes Source & OneToOne Logical Annotation Along With JoinColumn(Foreign Key Column Name) Will Be Applied As Shown In edu.gandhi.prajit.april.step03.entity.oto.EmployeeVersion01.

12:In BiDirectional OneToOne Case Assume ParkingSpace Reference Back To The Employee It Belongs To.Now In This Scenario,Both Entity Table Contain Foreign Key For Each Other(Employee Will Contain ParkingSpace Primary Key As Foregn Key & ParkingSpace Will Contain Employee Primary Key As Foreign Key).So We Can Make Any Of These Entity As Owner/Source & Other Entity As Target/Inverse.Recommened Way To Do It By The Most Frequent Direction Of Traversal.If Maximum User Traverse Employee To ParkingSpace Then We Can Make Employee As Source, Where For Parking Service Company Can Make Parking Space As Source.On Deciding Source We Use JoinColumn Annotation As Shown In edu.gandhi.prajit.april.step03.entity.oto.EmployeeVersion02.As ParkingSpace Is Now Inverse Side,No JoinColumn Information Needed.But If We Simply Put OneToOne In ParkingSpace Entity Then This Will Be 2 Separate UniDirectional Relationship.To Make This Part Of The Same Relationship/Make It BiDirectional We Used mappedBy As In edu.gandhi.prajit.april.step03.entity.oto.ParkingSpaceVersion02.Three Rules Are As Follows:
	
12:01:The Value Of mappedBy Is The Name Of The Attribute(Property/Field) In The Owning Entity That Points Back To The Inverse Entity.In Our Case parkingSpaceVersion02.
12:02:The @JoinColumn Annotation Goes On The Mapping Of The Entity That Is Mapped To The Table Containing The JoinColumn/Foreign Key,The Owner Of The Relationship.This Might Be On Either Side Of The Association.
12:03:The mappedBy Element Should Be Specified In The @OneToOne Annotation In The Entity That Does Not Define A JoinColumn/The Inverse Side Of The Relationship.

13:Collection Valued Association:When Source Entity Refers Many Target Entity.OneToMany&ManyToMany Are Of This Type.

14:OneToMany Relation Always Have ManyToOne CounterPart(OneToMany Always Implies ManyToOne Mapping Back To Source & ViceVersa).Its BiDirectional.So As In OneToOne Mapping We Can Split It Into 2 Relationship In Each Direction.ManyToOne Always Be The Owner As This Table Will Contain Same Foreign Key Value For Target Table(OneToMany Side).Employee Will Have DeptId As Foreign Key Which Is Primary Key For Department.See edu.gandhi.prajit.april.step03.entity.otm.EmployeeVersion01 & edu.gandhi.prajit.april.step03.entity.otm.DepartmentVersion01.
14:01:The ManyToOne Side Is The Owning Side,So The JoinColumn Is Defined On ThatSide.
14:02:The OneToMany Mapping Is The Inverse Side,So The mappedBy Element Must Be Used.Failing To Specify The mappedBy Element In The @OneToMany Annotation Will Cause The Provider To Treat It As A UniDirectional OneToMany Relationship That Is Defined To Use A JoinTable. 

15:ManyToMany:Employee(Many Employee,Single Project/Single Employee Many Project)&Project(Single Employee,Many Project/Many Employee Single Project).Here Any Side Can Be Owning Side & Other Side Will Be Inverse Side.Once We Decide Which One Will Be Source/Owning Entity,Other Entity Must Be Inverse.Default Join Table Name <OwnerEntity>_<InverseEntity>.joinColumns & inverseJoinColumns Can Be Multiple Column,In That Case We Can Use Array Of JoinColumns. Example Shown In edu.gandhi.prajit.april.step03.entity.mtm.EmployeeVersion02 & edu.gandhi.prajit.april.step03.entity.mtm.ProjectVersion02.The Default Name Of The JoinColumn That
Points To The Owning Entity Is The Name Of The Attribute On The Inverse Entity That Points To The Owning Entity,_,The Name Of The Primary Key Column Of The Owning Entity
Table.The Default Name Of The InverseJoinColumn That Points To The Inverse Entity Is The Name Of The Attribute On The Owing Entity That Points To The Inverse Entity,_,The Name Of The Primary Key Column Of The Inverse Entity Table.

16:UniDirectional OneToMany:No mappedBy Element In Target.Employee Can Have Multiple Phones.But Phone Does Not Refer Back To Employee As ManyToOne.Similar Case Happens With ManyToMany If Target Does Not Have mappedBy Element.Default Naming For The JoinColumns Is Different In The UniDirectional Case Because There Is No Inverse Attribute.The Name Of The Join Table Would Default To <OwningSideContaining JoinTable>_<CollectionTypeParameter> & Would Have A Join Column Named After The Name Of The Owning Entity&Its Primary Key Column.The Inverse Join Column Would Be Named With Concatenation Of The Collection Attribute In The Owning Entity & Primary Key Column Of The Collection Type.Ex:edu.gandhi.prajit.april.step03.entity.uniotm.EmployeeVersion01,edu.gandhi.prajit.april.step03.entity.uniotm.ProjectVersion01,edu.gandhi.prajit.april.step03.entity.uniotm.PhoneVersion01.For Default Name Generation See edu.gandhi.prajit.april.step03.entity.uniotm.EmployeeVersion02, edu.gandhi.prajit.april.step03.entity.uniotm.ProjectVersion02,edu.gandhi.prajit.april.step03.entity.uniotm.PhoneVersion02.

17:Embeded Types Can Be Defined By @Embeddable & Embed Them In Another Entity By @Embeded.In Case Column Definition Does Not Match With Entity Column Definition Where Embeddable Is Embeded,We Can Use @AttributeOverrides,@AttributeOverride.name Of AttributeOverride Will Be The Field Name Of Embeded Type & column Value Will Be Target Entity Column Name Using @Column Annottaion.Ex.edu.gandhi.prajit.april.step03.embed.Employee,edu.gandhi.prajit.april.step03.embed.Address, edu.gandhi.prajit.april.step03.embed.Company.

####Collection Mapping:Start
18:Collection Of Basic/Embeded Types Are ElementCollection,Collection Of Entity Are Relationships.Every ElementCollection Must Define A CollectionTable,Because Multiplicity Of Values Will Not Fit In The Single Row Of Containing Entity.So Every Collection Table Will Have JoinColumn That Refers To The Containing EntityTable. We Can Use CollectionTable Annotation But By Default Values Will Apply If The Annotation/Specific Elements Within That Annotation Are Not Specified.The Table Name Will Default To The Name Of The Referencing Entity,_,The Name Of The Entity Attribute That Contains The Element Collection.The JoinColumn Default Is Similarly The Name Of The Referencing Entity,_,The Name Of The Primary Key Column Of The Entity Table.We Can Mention @CollectionTable For Both Basic & Embeddable Types As In edu.gandhi.prajit.april.step05.elementcollection.EmployeeVersion02.@AttributeOverride Can Override Column Value In Embeddable.Always Code Over Collection,Set,List,Map Interface.The Moment The Entity Becomes Managed,The Persistence Provider Can Replace The Initial Concrete Instance With An Alternate Instance Of A Collection Implementation Class Of Its Own.

19:For List:Default OrderBy Annotation Is By Ascending Order.Default OrderBy PrimaryKey If List Parameterized Type Is Relationship/Reference Entity.ElementCollection Order Will Be Defined By Default Ordering From Database Without Order By Clause.To OrderBy Based On Embeddable Inside List<Type> Use Dot(.) Notation.See edu.gandhi.prajit.april.step03.elementcollection.DepartmentVersion01 For employeeVersion01s Attribute.Ordering Element In Memory Will Not Cause That Order Will Be Used In Database At Commit Time.When Apply @OrderColumn Attribute Must Be A List.See edu.gandhi.prajit.april.step03.elementcollection.DepartmentVersion02.But @OrderColumn Has Large Overhead, For N Entry If One Entry Change Position,It Will Update Each Row Once.Jpa Queries Will Be Better Option.
####Collection Mapping:End

20.By Default OneToMany&ManyToMany Use JoinTable.Inheritence Have 3 Strategies:SingleTablePerClass(All Attributes In The Hierarchy Are Part Of Same Single Table.Class A,Class B extends A,Class C extends A.All Attribute Means Class A Common Attribute+Class B Attributes+Class C Attributes+Additional Column To Identify Which Type Of Data Row Contains[Call It Discriminator Column To Identify Type A,B,C By Provider]), JoinedSubClass(Separate Table For Each Type[No Inherited Attributes Are Part Of Table].Must Be Joined Via Foreign Key Of A Type), TablePerConcreteClass(All Declared&Inherited Attribute Are Part Of Separate Table For Each Type).SingleTablePerClass Is Default Used In Root SuperClass.@DiscriminatorColumn Determine The ColumnName & Type.@DiscriminatorValue Applied To Each Type Including SuperClass To Provide Value For This Column.@MappedSuperclass Is Used When RootTable Is Not Required To Maintain The Hierarchy.Cascade & Fetch Types Will Be Discussed In Level.01,They Are Part Of All 4 Types Of Relationships.

21.