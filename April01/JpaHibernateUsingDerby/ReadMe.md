01.Derby Downloaded From https://db.apache.org/derby/releases/release-10.13.1.1.cgi.

02.Derby Started Using G:\WsApril17\DbDerby101311\bin\startNetworkServer.bat Script.See ScreenShot DerbyStarted.png.I Use It With Default Values.

03.Ddl Will Be Generated Automatically.Please Refer javax.persistence.schema-generation.database.action,javax.persistence.schema-generation.scripts.action.Location Is As Follows:javax.persistence.schema-generation.scripts.create-target,javax.persistence.schema-generation.scripts.drop-target.I Find It Helpful For Learning.

04.Jsr338(ToDo:MustRead):Specification.Standardized By Java Community Process.Jpa Needs A Runtime Provider Which Will Implement Jpa Specification.3 Implementation Are Available.EclipseLink,Hibernate,Apache OpenJpa.No Vendor Locking Benefit.

05.Managed Set Of Entities Is Called Persistence Context.Persistence Unit Is The Name For This Configuration.EntityManager Does Not Have Any Update Method.EntityManager Tracked When An Update Made To An Entity(Possibly Via Proxy).EntityManager Only Have persit,find & remove,merge(Method That Maked Detached Entity To Managed Entity) Method.

06.Jpa Use Convention Over Cofiguration/Configuration Is An Exception.Provider Apply This Default Rule.String(Varchar(255)).Annotation Can Be Applied On Field&Getters.Xml Overrides & Takes Precedence Over Annotation Metadata.If Database Info Got Changed Over Different Region Xml Usage. 

07.Direction:Traverse One Object From Another.UniDirectional/BiDirectional(Two UniDirectional).Cardinality(How Many Association Between Object).In Dbms Its Done By Primary Key,Foreign Key.In Oop Its Done By JoinColumn & JoinTable.

08.Every Story Has 3 Side(Yours,Mine,The Truth).First Is The View From One Side Of The Relationship,Second Is The View From Other Side Of The Relationship,Third One Is The Global Perspective That Knows About Both Side.Sides Are Called Role.One Entity Can Play Different Role In Different RelationShip.(Employee Entity Can Have Different Role In Department,Project,Even With Another Employee Entity As A Manager.).

09.Directionality:If Each Entity Point Back To Other Entity In A Relation Its BiDirectional.If Only One Entity Has A Pointer Then Its UniDirectional.Think Every BiDirectional Relationships As A Pair Of UniDirectional Relationship.So Based On Directionality We Refer One As Source Entity,Another One As Target Entity.Ex. Employee(Source) Works On A Project(Target),Project(Source) Consist Of Employees(Target).

10.Single Valued Association(OneToOne,ManyToOne):In Dbms Foreign Key Implements The Relationship.In Jpa Term That Is JoinColumn.Now One Of The Two Side Will Have JoinColumn/ForeignKey Is Called OwningSide/Owner Of The Relationship.Otherside Of The Relationship Called NonOwning/Inverse Side.Cardinal Annotation(OneToOne,OneToMany,ManyToOne,ManyToMany) Are Logical Annotation.But Physical Annotation Like JoinColumn/JoinTable Applies In The Owning Side.
For ManyToOne Relation Physical Annotation Mapping Will Be Always On Many Side.Employee->Department Is ManyToOne.In Db Employee Will Hold The Foreign Key For Department,No Otherway Around.As Employee Holds The Foreign Key,Employee Will Be Owning/Source Entity.JoinColumn Will Be The Foreign Key Column Name In Source Entity Table.JoinColumn Is Not Required But Only To Override Column Name.Default Rule As Follows:<Name Of The Relationship Attribute In Source Entity>_<Name Of The Primary Key Column In Target Entity>.In Our Case Let Say Employee Entity Have private Department department;(<Name Of The Relationship Attribute In Source Entity>) & Suppose Department Has private String id;As Primary Key Column<Name Of The Primary Key Column In Target Entity>.In This ManyToOne Case,Without @JoinColumn Annotation ColumnName Will Be Department_Id In Employee Source Table.We Have Treated This Relation As UniDirectional.If We Add @OneToMany(mappedBy = "departmentVersion01")private Collection<EmployeeVersion01> employeeVersion01s; In DepartmentVersion01(Shown In DepartmentVersion02,EmployeeVersion02).Then It Will Be BiDirectional.If We Omit mappedBy = "departmentVersion01" In @OneToMany(mappedBy = "departmentVersion01") Then This Will Be Two Separate UniDirectional Relation(Shown In DepartmentVersion03,EmployeeVersion03).

11.For OneToOne Relation Target Entity Is Not Shared Between Multiple Source Entity As In ManyToOne Case.Employee(Source,Table Has ForeignKey) Has ParkingSpace.In UniDirectional Case We Provide Annotation In Source Entity As In ManyToOne Case.To Decide Source Entity In This UniDirectional Case Assume Primary Key Of ParkingSpace Table Present In Employee Table As Foreign Key. So Employee Entity Becomes Source & OneToOne Logical Annotation Along With JoinColumn(Foreign Key Column Name) Will Be Applied As Shown In edu.gandhi.prajit.april.step03.entity.oto.EmployeeVersion01.

12.In BiDirectional OneToOne Case Assume ParkingSpace Reference Back To The Employee It Belongs To.Now In This Scenario,Both Entity Table Contain Foreign Key For Each Other(Employee Will Contain ParkingSpace Primary Key As Foregn Key & ParkingSpace Will Contain Employee Primary Key As Foreign Key).So We Can Make Any Of These Entity As Owner/Source & Other Entity As Target/Inverse.Recommened Way To Do It By The Most Frequent Direction Of Traversal.If Maximum User Traverse Employee To ParkingSpace Then We Can Make Employee As Source, Where For Parking Service Company Can Make Parking Space As Source.On Deciding Source We Use JoinColumn Annotation As Shown In edu.gandhi.prajit.april.step03.entity.oto.EmployeeVersion02.As ParkingSpace Is Now Inverse Side,No JoinColumn Information Needed.But If We Simply Put OneToOne In ParkingSpace Entity Then This Will Be 2 Separate UniDirectional Relationship.To Make This Part Of The Same Relationship/Make It BiDirectional We Used mappedBy As In edu.gandhi.prajit.april.step03.entity.oto.ParkingSpaceVersion02.Three Rules Are As Follows:
	
12:01:The Value Of mappedBy Is The Name Of The Attribute(Property/Field) In The Owning Entity That Points Back To The Inverse Entity.In Our Case parkingSpaceVersion02.
12:02:The @JoinColumn Annotation Goes On The Mapping Of The Entity That Is Mapped To The Table Containing The JoinColumn/Foreign Key,The Owner Of The Relationship.This Might Be On Either Side Of The Association.
12:03:The mappedBy Element Should Be Specified In The @OneToOne Annotation In The Entity That Does Not Define A JoinColumn/The Inverse Side Of The Relationship.